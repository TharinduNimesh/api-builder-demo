import { useEffect, useMemo, useState } from "react";

type ParamDef = {
  key: string;
  type?: string;
  location?: "path" | "query" | "body" | "header";
  required?: boolean;
  default?: string;
  description?: string;
  example?: string;
  // whether this param was auto-created from detected tokens
  autoGenerated?: boolean;
};

type Props = {
  open: boolean;
  onClose: () => void;
  initialSql: string;
  onSave: (cfg: { name: string; method: string; pathTemplate: string; params: ParamDef[]; sql: string }) => void;
};

function extractTokens(s: string) {
  const re = /\{([A-Za-z_][A-Za-z0-9_]*)\}/g;
  const out = new Set<string>();
  let m;
  // eslint-disable-next-line no-cond-assign
  while ((m = re.exec(s))) out.add(m[1]);
  return Array.from(out);
}

function substituteTokens(template: string, values: Record<string, string>) {
  return template.replace(/\{([A-Za-z_][A-Za-z0-9_]*)\}/g, (_, k) => {
    if (values[k] === undefined || values[k] === null || values[k] === "") return `{${k}}`;
    return String(values[k]);
  });
}

export default function EndpointModal({ open, onClose, initialSql, onSave }: Props) {
  const [name, setName] = useState("");
  const [method, setMethod] = useState("GET");
  const [pathTemplate, setPathTemplate] = useState("/");
  const [params, setParams] = useState<ParamDef[]>([]);
  const [sql, setSql] = useState<string>(initialSql);
  const [testValues, setTestValues] = useState<Record<string, string>>({});

  const detectedTokens = useMemo(() => extractTokens(sql + " " + pathTemplate), [sql, pathTemplate]);

  useEffect(() => {
    // Merge detected tokens with existing params deterministically and avoid duplicates.
    setParams((prev) => {
      // copy existing params
      const list = prev.slice();
      const keys = new Set(list.map((p) => p.key));

      // For each detected token, if it already exists keep it. If not, try to find an existing
      // autoGenerated param that is a prefix/expansion of the token and rename it.
      for (const t of detectedTokens) {
        if (keys.has(t)) continue;
        // find candidate auto-generated param to rename
        const idx = list.findIndex((p) => p.autoGenerated && (t.startsWith(p.key) || p.key.startsWith(t)));
        if (idx !== -1) {
          const oldKey = list[idx].key;
          // rename
          list[idx] = { ...list[idx], key: t };
          keys.delete(oldKey);
          keys.add(t);
        } else {
          // append new auto-generated param
          const inPath = pathTemplate.includes(`{${t}}`);
          const np: ParamDef = { key: t, type: "string", location: inPath ? "path" : "query", required: inPath, autoGenerated: true };
          list.push(np);
          keys.add(t);
        }
      }

      // remove stale autoGenerated params that are no longer detected
      const final = list.filter((p) => !(p.autoGenerated && !detectedTokens.includes(p.key)));
      // keep order: preserve existing order; ensure detected tokens are present in the order they were discovered
      // (we already appended new tokens in detected order)
      return final;
    });
  }, [detectedTokens.join(","), pathTemplate]);

  useEffect(() => {
    if (open) {
      // when opening, initialize SQL from editor and keep params in sync via detection
      setSql(initialSql);
      // reset test values so preview doesn't carry stale inputs
      setTestValues({});
      // If params are empty, seed them from detected tokens immediately
      // compute tokens from the provided initial SQL to avoid racing with internal sql state
      const initialTokens = extractTokens(initialSql + " " + pathTemplate);
      setParams((prev) => {
        if (prev.length > 0) return prev;
        const list: ParamDef[] = initialTokens.map((t) => ({
          key: t,
          type: "string",
          location: pathTemplate.includes(`{${t}}`) ? "path" : "query",
          required: pathTemplate.includes(`{${t}}`),
        }));
        return list;
      });
    } else {
      // when closing, clear transient form state
      setName("");
      setMethod("GET");
      setPathTemplate("/");
      setParams([]);
      setTestValues({});
    }
  }, [open, initialSql]);

  function updateParam(key: string, patch: Partial<ParamDef>) {
    setParams((ps) => ps.map((p) => (p.key === key ? { ...p, ...patch } : p)));
  }

  function addParam(key?: string) {
    const k = key ?? `p${params.length + 1}`;
    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(k)) return;
    if (params.find((p) => p.key === k)) return;
    setParams((s) => [...s, { key: k, type: "string", location: "query", required: false }]);
  }

  function removeParam(key: string) {
    setParams((s) => s.filter((p) => p.key !== key));
  }

  function handleSave() {
    // basic validation
    if (!name.trim()) return alert("Name is required");
    if (!pathTemplate.startsWith("/")) return alert("Path must start with /");
    onSave({ name: name.trim(), method, pathTemplate, params, sql });
    onClose();
  }

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40">
      <div className="w-11/12 max-w-4xl bg-white rounded shadow-lg overflow-auto max-h-[90vh]">
        <div className="p-4 border-b flex items-start justify-between">
          <div>
            <h3 className="text-lg font-semibold">Create Endpoint</h3>
            <div className="text-xs text-gray-500">Define HTTP method, path and dynamic parameters</div>
          </div>
          <div>
            <button onClick={onClose} className="text-gray-600">Close</button>
          </div>
        </div>

        <div className="p-4 grid grid-cols-12 gap-4">
          <div className="col-span-7">
            <div className="text-xs text-gray-600 mb-2">SQL / Query</div>
            <textarea value={sql} onChange={(e) => setSql(e.target.value)} className="w-full h-44 p-3 border border-gray-200 rounded text-sm font-mono" />

            <div className="mt-4 text-xs text-gray-600 mb-2">Request & SQL preview</div>
            <div className="border rounded p-3 bg-gray-50">
              <div className="text-sm font-mono">{method} {pathTemplate}</div>
              <div className="mt-2 text-xs text-gray-700">Params:</div>
              <ul className="text-xs">
                {params.length === 0 ? <li className="text-gray-400">(none)</li> : params.map((p) => (
                  <li key={p.key}>{p.key} — {p.location} — {p.type}{p.required ? ' — required' : ''}</li>
                ))}
              </ul>

              <div className="mt-3">
                <div className="text-xs font-medium">Substituted SQL</div>
                <pre className="bg-white p-2 rounded text-xs max-h-40 overflow-auto font-mono">{substituteTokens(sql, testValues)}</pre>
              </div>
            </div>
          </div>

          <div className="col-span-5">
            <div className="space-y-2">
              <label className="block text-xs">Endpoint name</label>
              <input value={name} onChange={(e) => setName(e.target.value)} className="w-full p-2 border rounded" />

              <label className="block text-xs">HTTP method</label>
              <select value={method} onChange={(e) => setMethod(e.target.value)} className="w-full p-2 border rounded">
                <option>GET</option>
                <option>POST</option>
                <option>PUT</option>
                <option>PATCH</option>
                <option>DELETE</option>
              </select>

              <label className="block text-xs">Path template</label>
              <input value={pathTemplate} onChange={(e) => setPathTemplate(e.target.value)} className="w-full p-2 border rounded font-mono" />

              <div className="pt-2">
                <div className="flex items-center justify-between">
                  <div className="text-sm font-medium">Dynamic parameters</div>
                  <div>
                    <button onClick={() => addParam()} className="text-sm px-2 py-1 bg-indigo-600 text-white rounded">Add</button>
                  </div>
                </div>
                <div className="mt-2 space-y-2">
                  {params.map((p) => (
                    <div key={p.key} className="p-2 border rounded">
                      <div className="flex items-center gap-2">
                        <div className="font-mono text-sm">{p.key}</div>
                        <div className="flex-1">
                          <select value={p.type} onChange={(e) => updateParam(p.key, { type: e.target.value })} className="p-1 border rounded text-xs">
                            <option value="string">string</option>
                            <option value="number">number</option>
                            <option value="boolean">boolean</option>
                            <option value="date">date</option>
                            <option value="json">json</option>
                          </select>
                          <select value={p.location} onChange={(e) => updateParam(p.key, { location: e.target.value as any })} className="p-1 border rounded text-xs ml-2">
                            <option value="path">path</option>
                            <option value="query">query</option>
                            <option value="body">body</option>
                            <option value="header">header</option>
                          </select>
                        </div>
                        <div className="text-xs">
                          <label className="inline-flex items-center gap-1"><input type="checkbox" checked={p.required} onChange={(e) => updateParam(p.key, { required: e.target.checked })} /> required</label>
                        </div>
                        <div>
                          <button onClick={() => removeParam(p.key)} className="text-red-600 text-xs">Remove</button>
                        </div>
                      </div>
                      <div className="mt-2 text-xs">
                        <input value={p.default ?? ""} onChange={(e) => updateParam(p.key, { default: e.target.value })} placeholder="default value (optional)" className="w-full p-1 border rounded text-xs" />
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              <div className="mt-4 border-t pt-3">
                <div className="flex items-center justify-between">
                  <div className="text-sm font-medium">Run / Test values</div>
                  <div className="text-xs text-gray-400">Preview substitution</div>
                </div>

                <div className="mt-2 space-y-2">
                  {params.length === 0 ? (
                    <div className="text-xs text-gray-400">No parameters defined</div>
                  ) : (
                    params.map((p) => (
                      <div key={p.key} className="flex items-center gap-2">
                        <div className="w-28 text-xs font-mono">{p.key}</div>
                        <input value={testValues[p.key] ?? ''} onChange={(e) => setTestValues((s) => ({ ...s, [p.key]: e.target.value }))} placeholder={p.example ?? p.default ?? ''} className="flex-1 p-1 border rounded text-xs" />
                      </div>
                    ))
                  )}
                </div>

                <div className="mt-3 text-xs">
                  <div className="font-medium">Preview URL</div>
                  <div className="font-mono text-sm">{substituteTokens(pathTemplate, testValues)}</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div className="p-4 border-t flex justify-end gap-2">
          <button onClick={onClose} className="px-3 py-2 border rounded">Cancel</button>
          <button onClick={handleSave} className="px-3 py-2 bg-green-600 text-white rounded">Save Endpoint</button>
        </div>
      </div>
    </div>
  );
}
